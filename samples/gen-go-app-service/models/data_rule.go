// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DataRule DataRule represents a rule on district configured by an app. The results of the rule are displayed on the data warnings page. Requirements for Rule Validity: - id is auto-generated by the app service when a rule is first created - simple rules apply validation on a document by document basis for a single field. They must have field set and can have field_required, max_length and regex set. - uniqueness rules validate that a field is unique across the entire data set. They only have a field set - custom rules exist for a College Board special case and don't have any of the other fields set. Severity of Rule Type: - warn indicates data may be not correct, but failing records are passed as is to app. - remove indicates app will not work for failing records and they will not be passed on to the app.
// swagger:model DataRule
type DataRule struct {

	// collection
	Collection string `json:"collection,omitempty"`

	// description
	Description string `json:"description,omitempty"`

	// field
	Field string `json:"field,omitempty"`

	// field required
	FieldRequired bool `json:"fieldRequired,omitempty"`

	// group by fields
	GroupByFields []string `json:"groupByFields"`

	// id
	ID string `json:"id,omitempty"`

	// max length
	MaxLength int64 `json:"maxLength,omitempty"`

	// regex
	Regex string `json:"regex,omitempty"`

	// rule type
	RuleType string `json:"ruleType,omitempty"`

	// severity
	Severity string `json:"severity,omitempty"`
}

// Validate validates this data rule
func (m *DataRule) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCollection(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateGroupByFields(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRuleType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSeverity(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataRuleTypeCollectionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["students","teachers","schools","sections","studentcontacts","schooladmins","courses","contacts","terms"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataRuleTypeCollectionPropEnum = append(dataRuleTypeCollectionPropEnum, v)
	}
}

const (
	// DataRuleCollectionStudents captures enum value "students"
	DataRuleCollectionStudents string = "students"
	// DataRuleCollectionTeachers captures enum value "teachers"
	DataRuleCollectionTeachers string = "teachers"
	// DataRuleCollectionSchools captures enum value "schools"
	DataRuleCollectionSchools string = "schools"
	// DataRuleCollectionSections captures enum value "sections"
	DataRuleCollectionSections string = "sections"
	// DataRuleCollectionStudentcontacts captures enum value "studentcontacts"
	DataRuleCollectionStudentcontacts string = "studentcontacts"
	// DataRuleCollectionSchooladmins captures enum value "schooladmins"
	DataRuleCollectionSchooladmins string = "schooladmins"
	// DataRuleCollectionCourses captures enum value "courses"
	DataRuleCollectionCourses string = "courses"
	// DataRuleCollectionContacts captures enum value "contacts"
	DataRuleCollectionContacts string = "contacts"
	// DataRuleCollectionTerms captures enum value "terms"
	DataRuleCollectionTerms string = "terms"
)

// prop value enum
func (m *DataRule) validateCollectionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataRuleTypeCollectionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataRule) validateCollection(formats strfmt.Registry) error {

	if swag.IsZero(m.Collection) { // not required
		return nil
	}

	// value enum
	if err := m.validateCollectionEnum("collection", "body", m.Collection); err != nil {
		return err
	}

	return nil
}

func (m *DataRule) validateGroupByFields(formats strfmt.Registry) error {

	if swag.IsZero(m.GroupByFields) { // not required
		return nil
	}

	return nil
}

var dataRuleTypeRuleTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["simple","uniqueness","custom","custom_dob_valid","custom_dob_range","dualenrollments","hasenrollments","uniqueenrollments","hasstudentcontacts","emptyschools","hascontacts","unlinkedadmins","teacher_staff_uniqueness","sectionhasschool"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataRuleTypeRuleTypePropEnum = append(dataRuleTypeRuleTypePropEnum, v)
	}
}

const (
	// DataRuleRuleTypeSimple captures enum value "simple"
	DataRuleRuleTypeSimple string = "simple"
	// DataRuleRuleTypeUniqueness captures enum value "uniqueness"
	DataRuleRuleTypeUniqueness string = "uniqueness"
	// DataRuleRuleTypeCustom captures enum value "custom"
	DataRuleRuleTypeCustom string = "custom"
	// DataRuleRuleTypeCustomDobValid captures enum value "custom_dob_valid"
	DataRuleRuleTypeCustomDobValid string = "custom_dob_valid"
	// DataRuleRuleTypeCustomDobRange captures enum value "custom_dob_range"
	DataRuleRuleTypeCustomDobRange string = "custom_dob_range"
	// DataRuleRuleTypeDualenrollments captures enum value "dualenrollments"
	DataRuleRuleTypeDualenrollments string = "dualenrollments"
	// DataRuleRuleTypeHasenrollments captures enum value "hasenrollments"
	DataRuleRuleTypeHasenrollments string = "hasenrollments"
	// DataRuleRuleTypeUniqueenrollments captures enum value "uniqueenrollments"
	DataRuleRuleTypeUniqueenrollments string = "uniqueenrollments"
	// DataRuleRuleTypeHasstudentcontacts captures enum value "hasstudentcontacts"
	DataRuleRuleTypeHasstudentcontacts string = "hasstudentcontacts"
	// DataRuleRuleTypeEmptyschools captures enum value "emptyschools"
	DataRuleRuleTypeEmptyschools string = "emptyschools"
	// DataRuleRuleTypeHascontacts captures enum value "hascontacts"
	DataRuleRuleTypeHascontacts string = "hascontacts"
	// DataRuleRuleTypeUnlinkedadmins captures enum value "unlinkedadmins"
	DataRuleRuleTypeUnlinkedadmins string = "unlinkedadmins"
	// DataRuleRuleTypeTeacherStaffUniqueness captures enum value "teacher_staff_uniqueness"
	DataRuleRuleTypeTeacherStaffUniqueness string = "teacher_staff_uniqueness"
	// DataRuleRuleTypeSectionhasschool captures enum value "sectionhasschool"
	DataRuleRuleTypeSectionhasschool string = "sectionhasschool"
)

// prop value enum
func (m *DataRule) validateRuleTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataRuleTypeRuleTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataRule) validateRuleType(formats strfmt.Registry) error {

	if swag.IsZero(m.RuleType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRuleTypeEnum("ruleType", "body", m.RuleType); err != nil {
		return err
	}

	return nil
}

var dataRuleTypeSeverityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["warn","remove"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataRuleTypeSeverityPropEnum = append(dataRuleTypeSeverityPropEnum, v)
	}
}

const (
	// DataRuleSeverityWarn captures enum value "warn"
	DataRuleSeverityWarn string = "warn"
	// DataRuleSeverityRemove captures enum value "remove"
	DataRuleSeverityRemove string = "remove"
)

// prop value enum
func (m *DataRule) validateSeverityEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataRuleTypeSeverityPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataRule) validateSeverity(formats strfmt.Registry) error {

	if swag.IsZero(m.Severity) { // not required
		return nil
	}

	// value enum
	if err := m.validateSeverityEnum("severity", "body", m.Severity); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataRule) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataRule) UnmarshalBinary(b []byte) error {
	var res DataRule
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
